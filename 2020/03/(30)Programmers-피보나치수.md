# 피보나치 수

피보나치 수는 F(0) = 0, F(1) = 1일 때, 1 이상의 n에 대하여<br/>
F(n) = F(n-1) + F(n-2)가 적용되는 수 입니다.

예를 들어

- F(2) = F(0) + F(1) = 0 + 1 = 1
- F(3) = F(1) + F(2) = 1 + 1 = 2
- F(4) = F(2) + F(3) = 1 + 2 = 3
- F(5) = F(3) + F(4) = 2 + 3 = 5

와 같이 이어집니다.

2 이상의 n이 입력되었을 때, n번째 피보나치 수를 1234567으로 나눈 나머지를 리턴하는 함수, solution을 완성해 주세요.

**제한 사항**

- n은 1이상, 100000이하인 자연수입니다.

입출력 예

|  n  | return |
|:---:|:---:|
| 3 | 2 |
| 5 | 5 |

**입출력 예 설명**

- 피보나치수는 0번째부터 0, 1, 1, 2, 3, 5, ... 와 같이 이어집니다.

## Problem-solving proccess

보통 피보나치 수, 혹은 팩토리얼 문제는 전통적으로 아래와 같이 재귀함수로 해결을 많이 했었다.

```javascript
function fibonacci(n) {
    return n < 2 ? n : fibonacci(n-1) + fibonacci(n-2)
}
```

하지만, 재귀함수는 자기 자신을 다시 호출하기 때문에 메모리 문제를 일으킬 수 있으며, stack overflow를 일으킬 수 있다. 때문에 n으로 들어가는 숫자가 커지면 대체로 알고리즘 문제에서 런타임 오류 등을 일으킨다.
이를 해결하기 위해 내가 쓴 방법은 메모이제이션(memoization)이란 방법이다.

메모이제이션(memoization)은 동일한 계산을 반복할 때, 이전에 계산한 값을 메모리에 저장함으로써(마치 메모하는 것처럼) 동일한 계산을 반복하는걸 줄여줌으로써 실행 속도를 빠르게 하는 방법이다.

따라서 메모이제이션을 이용한 나의 해답은 아래와 같다,

## Problem answer

```javascript
function solution(n) {
    let memo = [0,1];

    for(let i = 2; i <= n; i++) {
        memo.push((memo[i-1] + memo[i-2]) % 1234567);
    }

    return memo[n];
}
```
